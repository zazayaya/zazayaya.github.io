<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>多线程 on zaza的博客</title>
    <link>https://zazayaya.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B.html</link>
    <description>Recent content in 多线程 on zaza的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 23 Mar 2021 16:11:14 +0800</lastBuildDate><atom:link href="https://zazayaya.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python-多线程注意事项</title>
      <link>https://zazayaya.github.io/2021/03/23/python-threading-memory-leak.html</link>
      <pubDate>Tue, 23 Mar 2021 16:11:14 +0800</pubDate>
      
      <guid>https://zazayaya.github.io/2021/03/23/python-threading-memory-leak.html</guid>
      <description>锁申请位置错误导致内存泄露-多线程内存泄露注意事项 # encoding: UTF-8 import threading import time def show_fun(sem, n): # 不能放在这里 # sem_lock.acquire() print(&amp;#34;{0}start -- {1}&amp;#34;.format(time.ctime(), n)) print &amp;#34;working&amp;#34; time.sleep(2) print(&amp;#34;{0}end -- {1}&amp;#34;.format(time.ctime(), n)) sem.release() if __name__ == &amp;#39;__main__&amp;#39;: max_connections = 5 semaphore = threading.BoundedSemaphore(max_connections)</description>
    </item>
    
  </channel>
</rss>
